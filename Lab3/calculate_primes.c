#include "calculate_primes.h"

/* Функция реализует решето Эратосфена для нахождения простых чисел */
void calculate_primes(int primes[], int n) {
    /* Инициализация массива индикаторов */
    for (int i = 0; i <= n; i++) {
        primes[i] = 1; /* Считаем, что все числа простые */
    }
    primes[0] = primes[1] = 0; /* 0 и 1 — не простые числа */

    /* Реализация решета Эратосфена */
    for (int i = 2; i * i <= n; i++) {
        if (primes[i]) { /* Если i — простое число */
            for (int j = i * i; j <= n; j += i) {
                primes[j] = 0; /* Вычёркиваем числа кратные i */
            }
        }
    }
}


/* Комментарии к процессу:
	1) С начала помечаем все элементы массива как 1 (как простые числа)
	2) Помечаем 0 и 1 как 0 (исключаем их из простых чисел)
	3) Берём попорядку элементы массиваначиная с 2
	4) Цикл for перед if подставляет в i числа меньше или равные квадратному корню из n
	5) Цикл if проверяет числа primes[i] и если они отмечины как 0(исключаены их из простых чисел)
		то мы их пропускаем и возвращаемся к циклу for перед циклом if
	6) В цикле for в нутри if присваеваем 0(исключаем их из простых чисел) числам которые делятся на i
		так как они не уже не будут соответствовать условиям делится только на 1 или на себя
	7) Цикл продолжается до пока числа не дойдут до  n
	8) Возвращаемся к первому for с i+1

	Проверка производится до квадратного корня из n (Для разъяснения смотри комент в самом низу)
*/

/*Комент к (Проверка производится до квадратного корня из n)

	Цикл в алгоритме решета Эратосфена можно остановить после проверки чисел до sqrt(n),
        потому что все составные числа в диапазоне от 2 до n имеют хотя бы один простой делитель,
        меньший или равный sqrt(n). Давайте подробно разберём это.

        Основной принцип:
        Если число k является составным (т.е. не простым), его можно представить
        в виде произведения k = a*b, где a и b — натуральные числа, и:
        a<=sqrt(k), b>=sqrt(k).

        - Один из множителей (a) всегда будет меньше или равен sqrt(k), а другой (b) — больше или равен sqrt(k).
        - Если k делится на b>sqrt(k), то a уже был проверен, так как a<=sqrt(k).

	Пример для n = 50:
	Если n=50, то sqrt(50)≈7.07, и поэтому нужно проверять только числа i = 2, 3, 4, 5, 6, 7

	- Для i = 8: 8*6=48 (где 6 уже было проверено в цикле для i = 6).
	- Для i = 9: 9*5=45 (где 5 уже проверено в цикле для i = 5).
	- И так далее: любые составные числа с i>sqrt(n) уже вычеркнуты ранее.

	Оптимизация:
	Алгоритм работает быстрее, потому что мы:
	1. Не тратим время на проверку чисел, которые не влияют на результат (т.е. числа i>sqrt(n)).
	2. Обрабатываем только те числа, которые могут "вычёркивать" составные числа.

	Итог:
	Мы останавливаем цикл на i=sqrt(n), потому что все составные числа k>sqrt(n) уже вычеркнуты ранее,
	когда обрабатывались их меньшие делители a<=sqrt(n)
	Для n=50, это означает, что нужно обрабатывать только числа i = 2, 3, 4, 5, 6, 7 .
	После i=8 работа завершена

*/